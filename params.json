{"google":"","tagline":"Simple Rails glue for the Faye messaging protocol.","body":"# faye-rails [![Build Status](https://secure.travis-ci.org/jamesotron/faye-rails.png)](http://travis-ci.org/jamesotron/faye-rails)\r\n\r\nfaye-rails is a Ruby gem which handles embedding Faye's rack-based server into the rails stack and providing it with access to controllers and views based on bindings and observers.\r\n\r\n# Embedded server\r\n\r\nDue to the limitations of most Rack-based web servers available Faye can only be run on Thin, however if you are using thin, then you can add as many Faye servers as you want to the Rails router like so:\r\n\r\n    App::Application.routes.draw do\r\n      faye_server '/faye', :timeout => 25\r\n    end\r\n\r\nYou can also pass a block to `faye_server` which will be executed in the context of the Faye server, thus you can call any methods on `Faye::RackAdapter` from within the block:\r\n\r\n    App::Application.routes.draw do\r\n      faye_server '/faye', :timeout => 25 do\r\n        class MockExtension\r\n          def incoming(message, callback)\r\n            callback.call(message)\r\n          end\r\n        end\r\n        add_extension(MockExtension.new)\r\n      end\r\n    end\r\n\r\nIf you really want to, you can ask Faye to start it's own listening Thin server on an arbitrary port:\r\n\r\n    App::Application.routes.draw do\r\n      faye_server '/faye', :timeout => 25 do\r\n        listen(9292)\r\n      end\r\n    end\r\n\r\nYou can also do some rudimentary routing using the map method:\r\n\r\n    App::Application.routes.draw do\r\n      faye_server '/faye', :timeout => 25 do\r\n        map '/widgets/**' => WidgetsController\r\n        map :default => :block\r\n      end\r\n    end\r\n\r\nYou can find more details on the #map method in the [rdoc](http://rubydoc.info/github/jamesotron/faye-rails/master/FayeRails/RackAdapter)\r\n\r\n# Controller\r\n\r\nfaye-rails includes a controller for handling the binding between model events and channels with it's own DSL for managing channel-based events.\r\n\r\n    class WidgetController < FayeRails::Controller\r\n    end\r\n\r\n## Model observers\r\n\r\nYou can subscribe to changes in models using the controller's observer DSL:\r\n\r\n    class WidgetController < FayeRails::Controller\r\n      observe Widget, :after_create do |new_widget|\r\n        WidgetController.publish('/widgets', new_widget.attributes)\r\n      end\r\n    end\r\n\r\nThe available callbacks are derived from the ActiveRecord callback stack. See [ActiveRecord::Callbacks](http://api.rubyonrails.org/classes/ActiveRecord/Callbacks.html) for more information regarding the callback queue.\r\n\r\nSee the [rdoc](http://rubydoc.info/github/jamesotron/faye-rails/master/FayeRails/Controller.observe) for more information.\r\n\r\n## Channel DSL\r\n\r\nThe controller DSL elegantly wraps channel-based aspects of the Faye API so that you can easily group code based on specific channels.\r\n\r\n### Monitoring\r\n\r\nYou can make use of Faye's [monitoring API](http://faye.jcoglan.com/ruby/monitoring.html) by adding calls to `monitor` within the channel block. You are able to monitor `:subscribe`, `:unsubscribe` and `:publish` events. Blocks are executed within the context of a `FayeRails::Controller::Monitor` instance which will give you access to `#client_id`, `#channel` and `#data` (`#data` only having a value on `:publish` events).\r\n\r\n    class WidgetController < FayeRails::Controller\r\n      channel '/widgets' do\r\n        monitor :subscribe do\r\n          puts \"Client #{client_id} subscribed to #{channel}.\"\r\n        end\r\n        monitor :unsubscribe do\r\n          puts \"Client #{client_id} unsubscribed from #{channel}.\"\r\n        end\r\n        monitor :publish do\r\n          puts \"Client #{client_id} published #{data.inspect} to #{channel}.\"\r\n        end\r\n      end\r\n    end\r\n\r\n### Filtering\r\n\r\nYou can quickly and easily filter incoming and outgoing messages for your specific channel using the controller's filter API, which wraps Faye's [extensions API](http://faye.jcoglan.com/ruby/extensions.html) in a concise and channel-specific way.\r\n\r\n    class WidgetController < FayeRails::Controller\r\n      channel '/widgets' do\r\n        filter :in do\r\n          puts \"Inbound message #{message}.\"\r\n          pass\r\n        end\r\n      end\r\n    end\r\n\r\nYou can add filters for `:in`, `:out` and `:any`, which will allow you to filter messages entering the server, exiting the server or both. The block passed to the `filter` is executed in the context of a `FayeRails::Filter::DSL` instance, which gives you access to the `#message` method, which contains the entire message payload from the client (including meta information you wouldn't see other ways). You also have access to the `#pass`, `#modify`, `#block` and `#drop` methods which are sugar around Faye's callback system - which is accessible via the `#callback` method if you want to do it that way. Check out the [FayeRails::Filter::DSL rdoc](http://rubydoc.info/github/jamesotron/faye-rails/master/FayeRails/Filter/DSL) for more information.  Please note that all filters must call `callback.call` either via the sugar methods or directly to ensure that requests are not lost (not to mention potential memory leaks).\r\n\r\n### Subscribing\r\n\r\nYou can easily subscribe to a channel using the 'subscribe' method inside your channel block, like so:\r\n\r\n    class WidgetController < FayeRails::Controller\r\n      channel '/widgets' do\r\n        subscribe do\r\n          puts \"Received on channel #{channel}: #{message.inspect}\"\r\n        end\r\n      end\r\n    end\r\n\r\n# Thanks.\r\n\r\nThanks to James Coglan for the excellent Faye Bayeux implementetation and great support for Faye users.\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"faye-rails"}